
R version 3.4.2 (2017-09-28) -- "Short Summer"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "EcoGenetics"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "EcoGenetics-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('EcoGenetics')


 
                 --------------------- 
                    || EcoGenetics || 
                 --------------------- 
 
   Version 1.2.1-1 

   GitHub: https://github.com/leandroroser/EcoGenetics-devel 

   Online tutorial: https://leandroroser.github.io/EcoGenetics-Tutorial 

   Overview: help('EcoGenetics')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("EcoGenetics-accessors")
> ### * EcoGenetics-accessors
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: EcoGenetics accessors
> ### Title: Generic accessors for EcoGenetics objects
> ### Aliases: 'EcoGenetics accessors' ecoslot.XY,ecogen-method ecoslot.XY<-
> ###   ecoslot.XY<-,ecogen-method ecoslot.P ecoslot.P,ecogen-method
> ###   ecoslot.P<- ecoslot.P<-,ecogen-method ecoslot.G
> ###   ecoslot.G,ecogen-method ecoslot.G<- ecoslot.G<-,ecogen-method
> ###   ecoslot.A ecoslot.A,ecogen-method ecoslot.A<-,ecogen-method ecoslot.E
> ###   ecoslot.E,ecogen-method ecoslot.E<- ecoslot.E<-,ecogen-method
> ###   ecoslot.S ecoslot.S,ecogen-method ecoslot.S<-
> ###   ecoslot.S<-,ecogen-method ecoslot.C ecoslot.C,ecogen-method
> ###   ecoslot.C<- ecoslot.C<-,ecogen-method ecoslot.OUT
> ###   ecoslot.OUT,ecogen-method ecoslot.OUT<- ecoslot.OUT<-,ecogen-method
> ###   int.ecoslot.INT int.ecoslot.INT<- 'EcoGenetics accessors'
> ###   ecoslot.ALTER ecoslot.ANALYSIS ecoslot.ANOVA.MLM ecoslot.AVERAGE
> ###   ecoslot.BREAKS ecoslot.CARDINAL ecoslot.COND ecoslot.CONNECTED
> ###   ecoslot.DF1 ecoslot.DF2 ecoslot.DISTMETHOD ecoslot.EXP
> ###   ecoslot.FREQUENCIES ecoslot.IN ecoslot.LOGMEAN ecoslot.LWR
> ###   ecoslot.MEAN ecoslot.METHOD ecoslot.MLM ecoslot.MODEL ecoslot.MULTI
> ###   ecoslot.NAMES ecoslot.NONZERO ecoslot.NONZEROIND ecoslot.NSIM
> ###   ecoslot.OBS ecoslot.OBS.RES ecoslot.PADJUST ecoslot.PAR
> ###   ecoslot.PAR.VAL ecoslot.POLY.DEG ecoslot.POP ecoslot.PREDICTIONS
> ###   ecoslot.PVAL ecoslot.RES ecoslot.ROW.SD ecoslot.SELF ecoslot.SP
> ###   ecoslot.SUMMARY.MLM ecoslot.TEST ecoslot.TREES ecoslot.UPPR ecoslot.W
> ###   ecoslot.XY
> ### Keywords: datasets internal
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D #--------------
> ##D # GENERAL USE
> ##D #--------------
> ##D 
> ##D # Example 1
> ##D 
> ##D data(eco.test)
> ##D 
> ##D ## Test with phenotypic traits (example of ?eco.correlog)
> ##D moran <- eco.correlog(Z=eco[["P"]][,1], XY = eco[["XY"]], method = "I", smax=10, size=1000)
> ##D # the slots are accesed with the generic format:
> ##D # ecoslot. + name of the slot + (name of the object)
> ##D 
> ##D ecoslot.OUT(moran)      # slot OUT
> ##D ecoslot.BREAKS(moran)   # slot BREAKS
> ##D 
> ##D 
> ##D #----------------------------------------------
> ##D # SPECIFIC USE OF ACCESSORS WITH ECOGEN OBJECTS
> ##D #----------------------------------------------
> ##D 
> ##D #1) GET MODE
> ##D 
> ##D # Example 2
> ##D 
> ##D # Example with G data of class "data.frame", corresponding to
> ##D # microsatellites of a diploid organism.
> ##D 
> ##D eco <- ecogen(XY = coordinates, P = phenotype, G = genotype,
> ##D               E = environment, S = structure, order.G = TRUE)
> ##D eco              
> ##D 
> ##D 
> ##D # Access to the slots   
> ##D 
> ##D ecoslot.XY(eco) 
> ##D ecoslot.P(eco)
> ##D ecoslot.G(eco)
> ##D ecoslot.A(eco)
> ##D ecoslot.E(eco)
> ##D ecoslot.S(eco)
> ##D ecoslot.C(eco)
> ##D ecoslot.OUT(eco)         
> ##D 
> ##D # For ecogen objects, the double square brackets ("[[")
> ##D # are symbolic abbreviations of the accessors:
> ##D 
> ##D ecoslot.XY(eco) 
> ##D # is identical to:
> ##D eco[["XY"]]
> ##D 
> ##D #2) SET MODE (REPLACEMENT OF SLOTS)
> ##D 
> ##D # Example 3
> ##D 
> ##D eco <- ecogen(XY = coordinates, P = phenotype)
> ##D eco
> ##D 
> ##D ecoslot.G(eco, order.G = TRUE) <- genotype
> ##D 
> ##D # this is identical to
> ##D eco[["G", order.G=TRUE]] <- genotype
> ##D 
> ##D ecoslot.E(eco) <- environment
> ##D ecoslot.S(eco) <- structure
> ##D 
> ##D # Storing the data of Example 1 in the slot OUT
> ##D 
> ##D ecoslot.OUT(eco) <- moran
> ##D  
> ##D # Storing several data
> ##D singers <- c("carlos_gardel", "billie_holiday")
> ##D golden.number <- (sqrt(5) + 1) / 2
> ##D ecoslot.OUT(eco) <- list(singers, golden.number)    # several objects must be passed as a list
> ##D 
> ##D # In get mode, ecoslot.OUT has a double behavior:
> ##D # when only the name of the ecogen object is passed to
> ##D # the accessor, it has an overview method, 
> ##D # returning a data frame with the objects
> ##D # stored and their classes
> ##D 
> ##D ecoslot.OUT(eco)
> ##D 
> ##D # ecoslot.OUT in get mode, has two arguments:
> ##D # ecoslot.OUT(object, ...)
> ##D # here, the three dots (...) means any object(s) stored in the slot OUT.
> ##D 
> ##D ecoslot.OUT(eco, "moran", "singers")
> ##D 
> ##D # In double square brackets notation, this is equivalent to
> ##D eco[["OUT"]][c("moran", "singers")]
> ##D # This is, it works as a list and have no overview method
> ##D eco[["OUT"]]
> ##D eco[["OUT"]]["moran"]
> ##D 
> ##D # ecoslot.OUT in set mode, has two arguments:
> ##D # ecoslot.OUT(object, value)
> ##D # here value means object(s) to store in the slot OUT. Several objects
> ##D # must be passed as a list.
> ##D # The names of the input data is recoded in case of
> ##D # duplicates
> ##D 
> ##D ecoslot.OUT(eco) <- singers
> ##D ecoslot.OUT(eco)
> ##D ecoslot.OUT(eco) <- list(singers, singers, singers)
> ##D ecoslot.OUT(eco)
> ##D 
> ##D # The set operation is equivalent with double square brackets
> ##D eco[["OUT"]] <- list(singers, c(1,2,3))
> ##D ecoslot.OUT(eco)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("EcoGenetics-accessors", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("EcoGenetics-package")
> ### * EcoGenetics-package
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: EcoGenetics-package
> ### Title: Spatial Analysis of Phenotypic, Genotypic and Environmental Data
> ### Aliases: EcoGenetics-package EcoGenetics
> 
> ### ** Examples
> 
> 
>  ## Not run: 
> ##D  
> ##D  
> ##D #---Detrending spatial data with polynomial interpolation---#
> ##D  
> ##D  
> ##D data(eco2)
> ##D 
> ##D ## original data
> ##D data1 <- matrix(eco2[["P"]][,1], 30, 30)
> ##D image(data1)
> ##D 
> ##D ## original data + trend
> ##D data2 <- matrix(eco2[["P"]][,2], 30, 30)
> ##D image(data2)
> ##D 
> ##D ## data detrending
> ##D data2.det <- eco.detrend(Z = eco2[["P"]][,2], XY =  eco2[["XY"]], degree =  1)
> ##D data2.det <- ecoslot.RES(data2.det)
> ##D data2.det <- matrix(data2.det$df1, 30, 30)
> ##D image(data2.det)
> ##D 
> ##D 
> ##D #---Multiple Linear Regression fit---#
> ##D  
> ##D  
> ##D data(eco.test)
> ##D mymod <- "E1+E2*E3"
> ##D mod <- eco.lmtree(df1 = eco[["XY"]], df2 = eco[["E"]], 
> ##D analysis = "mlm", mod.class = mymod) 
> ##D summary(mod)
> ##D  
> ##D  
> ##D #---Multiple Conditional Inference Trees---#
> ##D 
> ##D 
> ##D data(eco.test)
> ##D mymod <- "E1+E2*E3"
> ##D mod <- eco.lmtree(df1 = eco[["P"]], df2 = eco[["E"]], 
> ##D analysis = "mctree", mod.class = mymod, fact = eco[["S"]]$structure)
> ##D summary(mod)
> ##D 
> ##D 
> ##D #---Global spatial analysis---#
> ##D  
> ##D  
> ##D ## Moran's I 
> ##D 
> ##D ### one test
> ##D data(eco.test)
> ##D con <- eco.weight(eco[["XY"]], method = "circle", d1 = 0, d2 = 2)
> ##D global <- eco.gsa(Z = eco[["P"]][, 1], con = con, , method = "I", nsim = 200)
> ##D global
> ##D 
> ##D require(adegenet)
> ##D con2<-chooseCN(eco[["XY"]], type = 1, result.type = "listw", plot.nb = FALSE)
> ##D global <- eco.gsa(Z = eco[["P"]][, 1], con = con2, , method = "I", nsim = 200)
> ##D global
> ##D 
> ##D ### multiple tests
> ##D con <- eco.weight(eco[["XY"]], method = "circle", d1 = 0, d2 = 2)
> ##D global <- eco.gsa(Z = eco[["P"]], con = con, , method = "I", nsim = 200)
> ##D global
> ##D 
> ##D 
> ##D ## Geary's C 
> ##D 
> ##D data(eco.test)
> ##D global.C <- eco.gsa(Z = eco[["P"]][, 1], con = con, method = "C", nsim = 200)
> ##D global.C
> ##D 
> ##D 
> ##D ## Bivariate's Moran's Ixy
> ##D 
> ##D data(eco.test)
> ##D global.Ixy <- eco.gsa(Z = eco[["P"]][, 1], Y = eco[["E"]][, 1],
> ##D con = con, method = "CC", nsim = 200)
> ##D global.Ixy
> ##D 
> ##D 
> ##D ## Join-Count
> ##D 
> ##D data(eco.test)
> ##D global.JC <- eco.gsa(Z = 2* eco[["A"]][, 1], ncod = 1,
> ##D con = con, method = "JC", nsim = 5)
> ##D global.JC
> ##D 
> ##D 
> ##D # Mantel test
> ##D 
> ##D data(eco.test)
> ##D eco.mantel(d1 = dist(eco[["P"]]), d2 = dist(eco[["E"]]), nsim = 99)  
> ##D 
> ##D 
> ##D ## Partial Mantel test
> ##D 
> ##D data(eco.test)
> ##D eco.mantel(d1 = dist(eco[["P"]]), d2 = dist(eco[["E"]]),
> ##D dc = dist(eco[["XY"]]), nsim = 99)  
> ##D 
> ##D 
> ##D #---Local spatial analysis---#
> ##D 
> ##D 
> ##D ## Getis-Ord's G*
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D con<- eco.weight(eco[["XY"]], method = "knearest",  k = 4, self = TRUE) 
> ##D ### self = TRUE for G*
> ##D getis.ak <- eco.lsa(eco[["P"]][, 1], con, method = "G*", nsim = 99, 
> ##D adjust = "none")
> ##D getis.ak
> ##D 
> ##D ### to plot the results, the function "eco.lsa" calls "eco.rankplot"
> ##D ### (see ?eco.rankplot) when test = "permutation" and "eco.forestplot"
> ##D ### (see ?eco.forestplot) when test = "bootstrap"
> ##D 
> ##D p <- plot(getis.ak)   ###  rankplot graph
> ##D p                     ###  points with colors of the color-scale:
> ##D                       ###  points with P < 0.05. Yellow points : 
> ##D                       ###  points with P > 0.05
> ##D p <- plot(getis.ak, significant = FALSE)
> ##D p                     ###  all points have a color of the color-scale
> ##D 
> ##D ### bootstrap example
> ##D getis.akb <- eco.lsa(eco[["P"]][, 1], con, method = "G*", nsim = 99,
> ##D test = "bootstrap")
> ##D p <- plot(getis.akb)     ### forestplot graph
> ##D p + ggplot2::theme_bw()  ### the plot can be modified with ggplot2
> ##D                          ### In this case, the background color is modified 
> ##D 
> ##D 
> ##D ## Getis-Ord's G
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D con<- eco.weight(eco[["XY"]], method = "knearest", k = 4)
> ##D ### self = FALSE for G
> ##D getis <- eco.lsa(eco[["P"]][, 1], con, method = "G", nsim = 99, adjust = "none")
> ##D plot(getis)
> ##D 
> ##D 
> ##D ## Local Moran's I
> ##D 
> ##D  #-------------------------
> ##D  # TESTING PHENOTYPIC DATA-
> ##D  #-------------------------
> ##D  
> ##D  con <- eco.weight(eco[["XY"]], method = "knearest",  k = 4, row.sd = TRUE) 
> ##D  # row standardized weights = TRUE
> ##D  
> ##D  # test for the first trait of the data frame P 
> ##D  localmoran <- eco.lsa(eco[["P"]][, 1], con, method = "I", nsim = 99)     
> ##D  
> ##D  plot(localmoran)
> ##D  
> ##D  # test for several variables
> ##D  
> ##D  all.traits <- apply(eco[["P"]], 2, eco.lsa,  con, method = "I", nsim = 99)
> ##D  
> ##D  # Observed statistic and P-values tables (individuals x traits)
> ##D  stat.P <- sapply(all.traits, function(x) return(ecoslot.OUT(x)[,1]))
> ##D  pval.P <- sapply(all.traits, function(x) return(ecoslot.OUT(x)[,4]))
> ##D  
> ##D  # Plot of the phenotypic spatial patterns
> ##D  
> ##D  par(mfrow = c(2,4))
> ##D  for(i in 1:8) {
> ##D  image(matrix(stat.P[,i], 15,15))
> ##D  }
> ##D  
> ##D  par(mfrow = c(2,4))
> ##D  for(i in 1:8) {
> ##D  image(matrix(pval.P[,i], 15,15))
> ##D  }
> ##D  
> ##D  
> ##D  #-------------------------
> ##D  # TESTING GENOTYPIC DATA-
> ##D  #-------------------------
> ##D  
> ##D  # eco[["A"]] is a matrix with the genetic data of "eco"
> ##D  # as frequencies for each allele in each individual
> ##D  # (use [["G"]] for presence-absence data).
> ##D  
> ##D  head(eco[["A"]])      # head of the matrix - 40 alleles
> ##D  
> ##D  con <- eco.weight(eco[["XY"]], method = "knearest",  k = 4, row.sd = TRUE) 
> ##D  # row standardized weights = TRUE
> ##D  
> ##D  # test for a single allele
> ##D  localmoran.geno <-  eco.lsa(eco[["A"]][, 32], con, method = "I", nsim = 99)
> ##D  
> ##D  # test for several alleles -  40 alleles (it runs in less than 1 min 
> ##D  # for 99 simulations per allele;  999 simulations takes ~ 11 s per allele, 
> ##D  # less than 8 min in total.) 
> ##D  all.alleles <- apply(eco[["A"]], 2, eco.lsa,  con, method = "I", nsim = 99)
> ##D  
> ##D  # plot all alleles to get an overview of the spatial patterns
> ##D  lapply(all.alleles, plot)
> ##D  
> ##D  # Observed statistic and P-values tables (individuals x loci)
> ##D  stat.G <- sapply(all.alleles, function(x) return(ecoslot.OUT(x)[,1]))
> ##D  pval.G <- sapply(all.alleles, function(x) return(ecoslot.OUT(x)[,4]))
> ##D  
> ##D  # counting individuals with P < 0.05 for each allele 
> ##D  # (5 * 225 /100 ~  12   significant tests by random)
> ##D  signif <- lapply(all.alleles, function(x) sum(ecoslot.OUT(x)[,4] < 0.05))
> ##D  signif <- unlist(signif)
> ##D  
> ##D  # filtering alleles, loci with > 12 significant individual tests
> ##D  
> ##D  A.local <- eco[["A"]][, signif > 12]     #filtered matrix
> ##D  stat.G.f <- stat.G[, signif > 12] 
> ##D  pval.G.f <- pval.G[, signif > 12]
> ##D  
> ##D  # Plot of the genotypic spatial patterns
> ##D  
> ##D  # one plot possibility, using the EcoGenetics method <rankplot>
> ##D  all.local <- all.alleles[signif > 12] 
> ##D  lapply(all.local, plot)
> ##D  
> ##D  # other plot possibility, using <image>
> ##D  par(mfrow = c(3,4))
> ##D  for(i in 1:12) {
> ##D  image(matrix(stat.G[,i], 15,15))
> ##D  }
> ##D  
> ##D  par(mfrow = c(3,4))
> ##D  for(i in 1:12) {
> ##D  image(matrix(pval.G[,i], 15,15))
> ##D  }
> ##D 
> ##D 
> ##D ## Local Geary's C
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D con<- eco.weight(eco[["XY"]], method = "knearest",  k = 4, row.sd = TRUE)
> ##D ### row standardized weights = TRUE
> ##D localgeary <- eco.lsa(eco[["P"]][, 1], con, method = "C", nsim = 99, 
> ##D adjust = "none")
> ##D plot(localgeary)
> ##D 
> ##D 
> ##D #---Moran's I, Geary's C and bivariate Moran's Ixy correlograms---#
> ##D 
> ##D 
> ##D ## Moran's I correlogram
> ##D 
> ##D ### single test
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D moran <- eco.correlog(Z=eco[["P"]][,1], XY = eco[["XY"]], method = "I",
> ##D smax=10, size=1000)
> ##D plot(moran)
> ##D 
> ##D ### multiple tests
> ##D moran2 <- eco.correlog(Z=eco[["P"]], XY = eco[["XY"]], method = "I",
> ##D smax=10, size=1000)
> ##D plot(moran2, var ="P2") ## single plots
> ##D plot(moran2, var ="P3") ## single plots
> ##D 
> ##D graf <- plot(moran2, meanplot = TRUE)  ## multiple plot with mean correlogram
> ##D                                        ## and jackknifed confidence intervals.
> ##D 
> ##D plot(graf[[1]])
> ##D plot(graf[[2]])
> ##D 
> ##D ### correlogram plots support the use of ggplot2 syntax
> ##D moranplot <- plot(moran2, var ="P3") + theme_bw() + theme(legend.position="none")
> ##D moranplot
> ##D 
> ##D 
> ##D ## Geary's C correlogram
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D geary <- eco.correlog(Z = eco[["P"]][,1], XY = eco[["XY"]], method = "C",
> ##D smax=10, size=1000)
> ##D plot(geary)
> ##D 
> ##D 
> ##D ## Moran's Ixy cross-correlogram
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D cross <- eco.correlog(Z = eco[["P"]][,1], XY = eco[["XY"]], Y = eco[["E"]][, 1],
> ##D method = "CC", int = 2, smax = 15)
> ##D plot(cross)
> ##D 
> ##D 
> ##D #---Mantel and partial Mantel correlograms---#
> ##D 
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D 
> ##D ## Mantel correlogram
> ##D 
> ##D corm <- eco.cormantel(M = dist(eco[["P"]]), size=1000,smax=7, XY = eco[["XY"]],
> ##D nsim = 99)
> ##D plot(corm)
> ##D 
> ##D corm <- eco.cormantel(M = dist(eco[["P"]]), size=1000,smax=7, XY = eco[["XY"]],
> ##D nsim = 99, test = "bootstrap")
> ##D plot(corm)
> ##D 
> ##D 
> ##D 
> ##D ## Partial Mantel correlogram
> ##D 
> ##D corm <- eco.cormantel(M = dist(eco[["P"]]), MC = dist(eco[["E"]]),
> ##D size=1000, smax=7, XY = eco[["XY"]], nsim = 99)
> ##D plot(corm)
> ##D 
> ##D ### correlogram plots support the use of ggplot2 syntax
> ##D mantelplot <- plot(corm) + theme_bw() + theme(legend.position="none")
> ##D mantelplot
> ##D 
> ##D 
> ##D #---Empirical variogram---#
> ##D 
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D variog <- eco.variogram(Z = eco[["P"]][, 2],XY =  eco[["XY"]])
> ##D plot(variog)
> ##D 
> ##D ### variogram plots support the use of ggplot2 syntax
> ##D variogplot <- plot(variog) + theme_bw() + theme(legend.position="none")
> ##D variogplot
> ##D 
> ##D  
> ##D #---Computing NDVI with atmospheric correction
> ##D #---over a time series, and estimation of the temporal mean---#
> ##D 
> ##D require(raster)
> ##D data(tab)
> ##D data(eco3)
> ##D set.seed(6)
> ##D 
> ##D temp <- list()
> ##D 
> ##D ## we create 4 simulated rasters for the data included in the object tab:
> ##D 
> ##D for(i in 1:4) {
> ##D temp[[i]] <- runif(19800, 0, 254)
> ##D temp[[i]] <- matrix(temp[[i]], 180, 110)
> ##D temp[[i]] <- raster(temp[[i]], crs="+proj=utm")
> ##D extent(temp[[i]])<-c(3770000, 3950000, 6810000, 6920000)
> ##D }
> ##D 
> ##D writeRaster(temp[[1]], "20040719b4.tif", overwrite = T)
> ##D writeRaster(temp[[2]], "20040719b3.tif", overwrite = T)
> ##D writeRaster(temp[[3]], "20091106b4.tif", overwrite = T)
> ##D writeRaster(temp[[4]], "20091106b3.tif", overwrite = T)
> ##D 
> ##D ## Computing NDVI images:
> ##D 
> ##D eco.NDVI(tab, "COST", "NDVI", "LT5")
> ##D 
> ##D ## Mean NDVI image computed over the NDVI images that we calculated:
> ##D 
> ##D eco.NDVI.post(tab, "COST", "NDVI", what = c("mean", "var"))
> ##D mean.ndvi <- raster("NDVI.COST.mean.tif")
> ##D plot(mean.ndvi)
> ##D 
> ##D ## Extraction of the mean NDVI for each point in the object eco and plot of the data:
> ##D 
> ##D ndvi <- extract(mean.ndvi, eco3[["XY"]])
> ##D ndvi<- aue.rescale(ndvi)
> ##D plot(eco3[["XY"]][, 1], eco3[["XY"]][, 2], col=rgb(ndvi, 0, 0),
> ##D pch=15, main = "Mean NDVI", xlab = "X", ylab  = "Y")
> ##D  
> ##D  
> ##D #---Theil-sen estimation for a raster---#
> ##D 
> ##D require("raster")
> ##D set.seed(6)
> ##D 
> ##D temp <- list()
> ##D 
> ##D for(i in 1:100) {
> ##D temp[[i]] <- runif(36,-1, 1)
> ##D temp[[i]] <- matrix(temp[[i]], 6, 6)
> ##D temp[[i]] <- raster::raster(temp[[i]])
> ##D }
> ##D 
> ##D temp <- brick(temp)
> ##D 
> ##D writeRaster(temp,"temporal.tif", overwrite=T)
> ##D rm(temp)
> ##D ndvisim <- brick("temporal.tif")
> ##D date <- seq(from = 1990.1, length.out = 100, by = 0.2)
> ##D eco.theilsen(ndvisim, date)
> ##D pvalue <- raster("pvalue.tif")
> ##D slope <- raster("slope.tif")
> ##D par(mfrow = c(1, 2))
> ##D plot(pvalue, main = "p-value")
> ##D plot(slope, main = "slope")
> ##D 
> ##D 
> ##D #---Conversion of ecogen data to several formats and format tool---#
> ##D 
> ##D 
> ##D ## Interconverting an ecogen genetic data frame among several formats 
> ##D 
> ##D data(eco3)
> ##D 
> ##D ### One allele per column
> ##D loc2al <- eco.convert(eco3[["G"]], "matrix", "alleles.matrix", ploidy = 2)
> ##D loc2al
> ##D 
> ##D ### Inverse operation (collapse alleles into locus)
> ##D al2loc <- eco.convert(loc2al, "alleles.matrix", "matrix", ploidy = 2)
> ##D al2loc
> ##D 
> ##D ### Separating alleles with a character string
> ##D loc2loc <- eco.convert(eco3[["G"]], "matrix", "matrix", ploidy = 2, sep.out = "/")
> ##D loc2loc
> ##D 
> ##D ### Inverse operation (removing separator)
> ##D loc2loc.nosep <- eco.convert(loc2loc, "matrix", "matrix", ploidy = 2, sep.in = "/", sep.out = "")
> ##D loc2loc.nosep
> ##D 
> ##D 
> ##D ## Format tool
> ##D 
> ##D data(eco.test)
> ##D 
> ##D ### Adding zeros
> ##D 
> ##D example <- as.matrix(genotype[1:10,])
> ##D mode(example) <- "character"
> ##D ### example data
> ##D example
> ##D recoded <- eco.format(example, ncod = 1, ploidy = 2, nout = 3)
> ##D ### recoded data
> ##D recoded
> ##D ### leading zeros
> ##D recoded2 <- eco.format(example, ncod = 1, ploidy = 2, nout = 3, 
> ##D fill.mode = "first")
> ##D ### recoded data
> ##D recoded2
> ##D 
> ##D 
> ##D ### Tetraploid data, separating alleles with a "/"
> ##D tetrap <- as.matrix(example)
> ##D ### simulated tetraploid example data
> ##D tetrap <- matrix(paste(example,example, sep = ""), ncol = ncol(example))
> ##D recoded <- eco.format(tetrap, ncod = 1, ploidy = 4, sep.out = "/")
> ##D ### recoded data
> ##D recoded
> ##D 
> ##D 
> ##D ## Creating input data for Geneland with an ecogen object
> ##D 
> ##D data(eco.test)
> ##D eco.2geneland(eco, 1)
> ##D 
> ##D 
> ##D ## Exporting an ecogen genetic data frame into Genepop format
> ##D 
> ##D data(eco.test)
> ##D eco.2genepop(eco, grp = "pop", name = "infile.genepop.txt")
> ##D ### an output file "infile.genepop.txt" is generated in the working directory
> ##D 
> ##D 
> ##D ## Converting a diploid ecogen genetic data frame into a gstudio object
> ##D 
> ##D data(eco.test)
> ##D gsteco <- eco.2gstudio(eco, "separated")
> ##D gsteco
> ##D 
> ##D 
> ##D ## Converting an ecogen genetic data frame into a hierfstat data frame
> ##D 
> ##D data(eco.test)
> ##D hiereco <- eco.2hierfstat(eco, "pop")
> ##D 
> ##D 
> ##D ## Exporting an ecogen genetic data frame into SPAGeDI format
> ##D 
> ##D data(eco.test)
> ##D eco.2spagedi(eco, "pop", ndig = 1,int=2, smax=6, name="infile.spagedi.txt")
> ##D 
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("EcoGenetics-package", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aue.image2df")
> ### * aue.image2df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aue.image2df
> ### Title: Transforming a raster into a data frame with cartesian
> ###   coordinates
> ### Aliases: aue.image2df
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D ras <- matrix(eco[["P"]][,1],15,15)
> ##D image(ras)
> ##D ras.row <- aue.image2df(ras)
> ##D ras.row
> ##D image(matrix(ras.row[,3], 15, 15))
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aue.image2df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aue.rescale")
> ### * aue.rescale
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aue.rescale
> ### Title: Scaling a data frame or matrix to [0, 1] or [-1, 1] ranges
> ### Aliases: aue.rescale
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D require(adegenet)
> ##D pc <- dudi.pca(eco[["P"]], scannf = FALSE, nf = 3)
> ##D pc <- pc$li
> ##D pc <- aue.rescale(pc)
> ##D plot(eco[["XY"]][, 1], eco[["XY"]][, 2], col = rgb(pc), pch = 16, 
> ##D cex = 1.5, xlab ="X", ylab= "Y")
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aue.rescale", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("aue.sort")
> ### * aue.sort
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: aue.sort
> ### Title: Ordering the content of cells in a matrix. Ordering alleles in a
> ###   genetic matrix.
> ### Aliases: aue.sort
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D # Example 1----------------------
> ##D 
> ##D geno <- c(12, 52, 62, 45, 54, 21)
> ##D geno <- matrix(geno, 3, 2)
> ##D 
> ##D # ordering the data
> ##D aue.sort(geno, ploidy = 2)
> ##D 
> ##D # decreasing sort order
> ##D aue.sort(geno, ploidy = 2, decreasing = TRUE)
> ##D 
> ##D 
> ##D # Example 2----------------------
> ##D 
> ##D geno2 <- c(123456, 524556, 629359, 459459, 543950, 219405)
> ##D geno2 <- matrix(geno2, 3, 2)
> ##D 
> ##D # ordering the data as diploid
> ##D aue.sort(geno2, ploidy = 2)  # the data is ordered using blocks of 3 characters
> ##D 
> ##D # ordering the data as triploid
> ##D aue.sort(geno2, ploidy = 3)  # the data is ordered using blocks of 2 characters
> ##D 
> ##D # error: the ploidy and the number of characters are not congruent
> ##D aue.sort(geno2, ploidy = 5) 
> ##D 
> ##D # error: the ploidy and the number of characters are not congruent
> ##D aue.sort(geno2, ploidy = 5)
> ##D 
> ##D 
> ##D # Example 3----------------------
> ##D 
> ##D # any character data
> ##D generic <- c("aldk", "kdbf", "ndnd", "ndkd")
> ##D generic <- matrix(generic, 2, 2)
> ##D aue.sort(generic, ploidy = 2) 
> ##D aue.sort(generic, ploidy = 4)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("aue.sort", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.NDVI")
> ### * eco.NDVI
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.NDVI
> ### Title: Generation of atmospherically corrected NDVI and MSAVI2 images
> ###   for temporal series of Landsat 5 and 7
> ### Aliases: eco.NDVI
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(raster)
> ##D 
> ##D data(tab)
> ##D 
> ##D temp <-list()
> ##D 
> ##D # we create 4 simulated rasters for the data included in the object tab:
> ##D 
> ##D for(i in 1:4) {
> ##D temp[[i]] <- runif(19800, 0, 254)
> ##D temp[[i]] <- matrix(temp[[i]], 180, 110)
> ##D temp[[i]] <- raster(temp[[i]], crs="+proj=utm")
> ##D extent(temp[[i]])<-c(3770000, 3950000, 6810000, 6920000)
> ##D }
> ##D 
> ##D writeRaster(temp[[1]], "20040719b4.tif", overwrite=T)
> ##D writeRaster(temp[[2]], "20040719b3.tif", overwrite=T)
> ##D writeRaster(temp[[3]], "20091106b4.tif", overwrite=T)
> ##D writeRaster(temp[[4]], "20091106b3.tif", overwrite=T)
> ##D 
> ##D # Computing NDVI images: 
> ##D 
> ##D eco.NDVI(tab, "COST", "NDVI", "LT5")
> ##D 
> ##D example <- raster("NDVICOST20040719.tif")
> ##D image(example)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.NDVI", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.NDVI.post")
> ### * eco.NDVI.post
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.NDVI.post
> ### Title: Postprocessing for NDVI and MSAVI2 temporal series of Landsat 5
> ###   and 7
> ### Aliases: eco.NDVI.post
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(raster)
> ##D 
> ##D data(tab)
> ##D data(eco3)
> ##D temp <- list()
> ##D 
> ##D # we create 4 simulated rasters for the data included in the object tab:
> ##D 
> ##D for(i in 1:4) {
> ##D temp[[i]] <- runif(19800, 0, 254)
> ##D temp[[i]] <- matrix(temp[[i]], 180, 110)
> ##D temp[[i]] <- raster(temp[[i]], crs="+proj=utm")
> ##D extent(temp[[i]])<-c(3770000, 3950000, 6810000, 6920000)
> ##D }
> ##D 
> ##D writeRaster(temp[[1]], "20040719b4.tif", overwrite = T) 
> ##D writeRaster(temp[[2]], "20040719b3.tif", overwrite = T)
> ##D writeRaster(temp[[3]], "20091106b4.tif", overwrite = T)
> ##D writeRaster(temp[[4]], "20091106b3.tif", overwrite = T)
> ##D 
> ##D # Computing NDVI images: 
> ##D 
> ##D eco.NDVI(tab, "COST", "NDVI", "LT5")
> ##D 
> ##D # Mean NDVI image computed over the NDVI images that we calculated:
> ##D 
> ##D eco.NDVI.post(tab, "COST", "NDVI", what = c("mean", "var"))
> ##D mean.ndvi <- raster("NDVI.COST.mean.tif")
> ##D plot(mean.ndvi)
> ##D 
> ##D # Extraction of the mean NDVI for each point in the object eco and plot
> ##D # of the data:
> ##D 
> ##D ndvi <- extract(mean.ndvi, eco3[["XY"]])
> ##D ndvi<- aue.rescale(ndvi)
> ##D plot(eco3[["XY"]][, 1], eco3[["XY"]][, 2], col=rgb(ndvi, 0, 0),
> ##D pch=15, main = "Mean NDVI", xlab = "X", ylab  = "Y")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.NDVI.post", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.alfreq")
> ### * eco.alfreq
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.alfreq
> ### Title: Allelic frequency histograms for an ecogen genetic data frame
> ### Aliases: eco.alfreq
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D eco.alfreq(eco)
> ##D eco.alfreq(eco, "pop")
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.alfreq", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.association")
> ### * eco.association
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.association
> ### Title: Chi-square and Fisher's exact test for association of loci and
> ###   alleles with a factor
> ### Aliases: eco.association
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D eco.association(eco, "within", "pop")
> ##D eco.association(eco, "within", "pop", adjust="fdr")
> ##D eco.association(eco, "within", "pop", method = "chisq.test")
> ##D eco.association(eco, "between", "pop", ndig = 1)
> ##D eco.association(eco, "between", "pop", method = "chisq.test", ndig = 1)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.association", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.bearing")
> ### * eco.bearing
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.bearing
> ### Title: Angular Spatial Weights
> ### Aliases: eco.bearing
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco3)
> ##D 
> ##D "circle" method
> ##D 
> ##D con <- eco.weight(eco3[["XY"]], method = "circle", d1 = 0, d2 = 500)
> ##D bearing_con <- eco.bearing(con, 90)
> ##D 
> ##D W_list <- eco.lagweight(eco[["XY"]]) 
> ##D bearing_W_list <- eco.bearing(W_list, 90)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.bearing", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.cbind")
> ### * eco.cbind
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.cbind
> ### Title: Combining ecogen object by column
> ### Aliases: eco.cbind
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D eco.example <- eco.cbind(eco,eco,"ALL")
> ##D eco.example
> ##D eco.example2 <- eco.cbind(eco, eco,"P", "G", missing="NA")
> ##D eco.example2
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.cbind", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.clear")
> ### * eco.clear
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.clear
> ### Title: Clearing the working environment, maintaining only the specified
> ###   objects
> ### Aliases: eco.clear
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D ls()
> ##D eco.clear(eco)
> ##D ls()
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.clear", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.convert")
> ### * eco.convert
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.convert
> ### Title: Conversion utility for genetic data
> ### Aliases: eco.convert
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco3)
> ##D 
> ##D # One allele per column
> ##D loc2al <- eco.convert(eco3[["G"]], "matrix", "alleles.matrix", ploidy = 2)
> ##D loc2al     
> ##D 
> ##D # Inverse operation (collapse alleles into locus)
> ##D al2loc <- eco.convert(loc2al, "alleles.matrix", "matrix", ploidy = 2)
> ##D al2loc
> ##D 
> ##D # Separating alleles with a character string
> ##D loc2loc <- eco.convert(eco3[["G"]], "matrix", "matrix", ploidy = 2, sep.out = "/")
> ##D loc2loc
> ##D 
> ##D # Inverse operation (removing separator)
> ##D loc2loc.nosep <- eco.convert(loc2loc, "matrix", "matrix", ploidy = 2, sep.in = "/", sep.out = "")
> ##D loc2loc.nosep
> ##D 
> ##D # Locus to list
> ##D loc2list <- eco.convert(eco3[["G"]], "matrix", "list", ploidy = 2)
> ##D loc2list
> ##D 
> ##D # Locus to allele list
> ##D al2list <- eco.convert(eco3[["G"]], "matrix",  "alleles.list", ploidy = 2)
> ##D al2list
> ##D 
> ##D # The inverse operations are also defined. All the formats are interconvertible.
> ##D # Locus operations have defined a within operation (matrix to matrix, list to list), 
> ##D # with the purpose of put/remove separators between alleles. The program accepts any ploidy level. 
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.convert", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.cormantel")
> ### * eco.cormantel
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.cormantel
> ### Title: Mantel and partial Mantel correlograms, omnidirectional and
> ###   directional
> ### Aliases: eco.cormantel
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D 
> ##D ###############################
> ##D ## Omnidirectional correlogram
> ##D ###############################
> ##D 
> ##D corm <- eco.cormantel(M = dist(eco[["P"]]), size=1000,smax=7, XY = eco[["XY"]],
> ##D nsim = 99)
> ##D eco.plotCorrelog(corm)
> ##D 
> ##D corm <- eco.cormantel(M = dist(eco[["P"]]), size=1000,smax=7, XY = eco[["XY"]],
> ##D nsim = 99, test = "bootstrap")
> ##D eco.plotCorrelog(corm)
> ##D 
> ##D #######################################################
> ##D ## A directional approach based in bearing correlograms
> ##D #######################################################
> ##D 
> ##D corm_b <- eco.cormantel(M = dist(eco[["P"]]), size=1000,smax=7, XY = eco[["XY"]],
> ##D nsim = 99, angle = seq(0, 170, 10))
> ##D 
> ##D  # use eco.plotCorrelogB for this object
> ##D eco.plotCorrelogB(corm_b)
> ##D 
> ##D  # plot for the first distance class, 
> ##D  use a number between 1 and the number of classes to select the corresponding class
> ##D eco.plotCorrelogB(corm_b, interactivePlot = FALSE, var = 1) 
> ##D 
> ##D # partial Mantel correlogram
> ##D corm <- eco.cormantel(M = dist(eco[["P"]]), MC = dist(eco[["E"]]),
> ##D size=1000, smax=7, XY = eco[["XY"]], nsim = 99)
> ##D eco.plotCorrelog(corm)
> ##D 
> ##D # standard correlogram plots support the use of ggplot2 syntax
> ##D require(ggplot2)
> ##D mantelplot <- eco.plotCorrelog(corm, interactivePlot = FALSE)
> ##D mantelplot <- mantelplot + theme_bw() + theme(legend.position="none")
> ##D mantelplot
> ##D 
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accesed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.OUT(corm)        # slot OUT
> ##D ecoslot.BREAKS(corm)     # slot BREAKS
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.cormantel", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.correlog-methods")
> ### * eco.correlog-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot,eco.correlog,ANY-method
> ### Title: globalplot
> ### Aliases: plot,eco.correlog,ANY-method plot,eco.correlog-method
> ###   show,eco.correlog-method
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D # single Moran's I correlogram analysis
> ##D moran.example <- eco.correlog(Z=eco[[P]][,1], eco$XY, smax=10, size=1000)
> ##D plot(moran.example)
> ##D 
> ##D # multiple Moran's I correlogram analysis
> ##D moran.example2 <- eco.correlog(Z=eco[[P]], eco$XY, smax=10, size=1000)
> ##D plot(moran.example2, var ="P2")
> ##D plot(moran.example2, var ="P3")
> ##D 
> ##D corm <- eco.cormantel(M = dist(eco[[P]]), size=1000,smax=7, XY = eco$XY,
> ##D nsim = 99)
> ##D plot(corm)
> ##D 
> ##D variog <- eco.variogram(Z = eco[[P]][, 2],XY =  eco$XY)
> ##D plot(variog)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.correlog-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.correlog")
> ### * eco.correlog
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.correlog
> ### Title: Moran's I, Geary's C and bivariate Moran's I correlograms,
> ###   omnidirectional and directional
> ### Aliases: eco.correlog
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D 
> ##D 
> ##D ##########################
> ##D # Moran's I correlogram
> ##D ##########################
> ##D 
> ##D ## single test with phenotypic traits
> ##D moran <- eco.correlog(Z=eco[["P"]][,1], XY = eco[["XY"]], 
> ##D method = "I", smax=10, size=1000)
> ##D 
> ##D # interactive plot via plotly
> ##D eco.plotCorrelog(moran)
> ##D 
> ##D # standard plot via ggplot2
> ##D eco.plotCorrelog(moran, interactivePlot = FALSE)
> ##D 
> ##D 
> ##D #-------------------------------------------------------
> ##D ## A directional approach based in bearing correlograms
> ##D #-------------------------------------------------------
> ##D 
> ##D moran_b <- eco.correlog(Z=eco[["P"]][,1], XY = eco[["XY"]], 
> ##D method = "I", smax = 10, size = 1000, angle  = seq(0, 175, 5))
> ##D 
> ##D  # use eco.plotCorrelogB for this object
> ##D eco.plotCorrelogB(moran_b)
> ##D 
> ##D  # plot for the first distance class, 
> ##D  use a number between 1 and the number of classes to select the corresponding class
> ##D eco.plotCorrelogB(moran_b, var = 1) 
> ##D 
> ##D #-----------------------------
> ##D ## Multivariable correlograms
> ##D #-----------------------------
> ##D 
> ##D ## multiple tests with phenotypic traits
> ##D moran2 <- eco.correlog(Z=eco[["P"]], XY = eco[["XY"]],
> ##D method = "I", smax=10, size=1000)
> ##D 
> ##D eco.plotCorrelog(moran2, var ="P2") ## single plots
> ##D eco.plotCorrelog(moran2, var ="P3") ## single plots
> ##D 
> ##D 
> ##D  ## Multivariable interactive plot with mean correlogram 
> ##D  ## and jackknifed confidence intervals.
> ##D  
> ##D  graf <- eco.plotCorrelog(moran2, meanplot = TRUE)
> ##D  
> ##D  # Only mean
> ##D  graf$mean.correlog
> ##D  
> ##D  # Mean and variables
> ##D  graf$multi.correlog
> ##D  
> ##D  # Information
> ##D  - correlogram data for individual variables
> ##D  - manhattan distance matrix
> ##D  - mean correlogram data
> ##D  - method used for analysis
> ##D  - names and numbers (column in data frame) of significant variables 
> ##D  
> ##D  
> ##D  
> ##D  graf$data
> ##D  
> ##D  
> ##D  # plot only alleles
> ##D  graf <- eco.plotCorrelog(moran2, meanplot = FALSE)
> ##D  graf
> ##D  
> ##D  # Both plots can also be constructed using ggplot2
> ##D  
> ##D  gg_graf <- eco.plotCorrelog(moran2, meanplot = TRUE, interactivePlot = FALSE)
> ##D  gg_graf[[1]]
> ##D  gg_graf[[2]]
> ##D  
> ##D  gg_graf <- eco.plotCorrelog(moran2, meanplot = FALSE, interactivePlot = FALSE)
> ##D  gg_graf
> ##D 
> ##D 
> ##D # standard ggplot2 correlograms support the use of ggplot2 syntax
> ##D require(ggplot2)
> ##D moranplot <- eco.plotCorrelog(moran2, var ="P3", interactivePlot = FALSE) 
> ##D moranplot <- moranplot + theme_bw() + theme(legend.position="none")
> ##D moranplot
> ##D 
> ##D moranplot2 <- gg_graf[[2]] + theme_bw() + theme(legend.position="none")
> ##D moranplot2
> ##D 
> ##D 
> ##D #-----------------------
> ##D Analyzing genetic data
> ##D #-----------------------
> ##D 
> ##D # single test with genotypic traits
> ##D 
> ##D # eco[["A"]] is a matrix with the genetic data of "eco" 
> ##D # as frequencies for each allele in each individual. Each allele
> ##D # can be analyzed as single traits. 
> ##D 
> ##D head(eco[["A"]])      # head of the matrix
> ##D 
> ##D # analyzing allele 1
> ##D moran <- eco.correlog(Z=[["A"]][,1], XY = eco[["XY"]], method = "I",
> ##D smax=10, size=1000)                
> ##D eco.plotCorrelog(moran)
> ##D 
> ##D # multiple tests with genotypic traits. 
> ##D # nsim is set to 10 only for speed in the example
> ##D moran2 <- eco.correlog(Z = eco[["A"]], XY = eco[["XY"]], 
> ##D method = "I",smax=10, size=1000, nsim=99)
> ##D 
> ##D 
> ##D ## multiple plot with mean 
> ##D ## correlogram and jackknifed 
> ##D ## confidence intervals.
> ##D 
> ##D graf <- eco.plotCorrelog(moran2, meanplot = TRUE)
> ##D 
> ##D ## the same example, but with nsim = 99. 
> ##D moran3 <- eco.correlog(Z = eco[["A"]], XY = eco[["XY"]], method = "I", 
> ##D smax=10, size=1000, nsim=99)  
> ##D        
> ##D ## plot for alleles with at least one significant value after
> ##D ## Bonferroni-Holm sequential P correction
> ##D ## (set adjust "none" for no family-wise 
> ##D ## P correction in "eco.correlog")
> ##D 
> ##D eco.plotCorrelog(moran3, meanplot = TRUE, significant.M = TRUE)
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accesed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.OUT(moran)      # slot OUT
> ##D ecoslot.BREAKS(moran)   # slot BREAKS
> ##D                                              
> ##D #---------------------------------------------------------------------------#
> ##D 
> ##D ##########################
> ##D # Geary's C correlogram
> ##D ##########################
> ##D 
> ##D geary <- eco.correlog(Z = eco[["P"]][,1], XY = eco[["XY"]], method = "C",
> ##D smax=10, size=1000)
> ##D # Interactive plot
> ##D eco.plotCorrelog(geary)
> ##D # ggplot2 plot
> ##D eco.plotCorrelog(geary, interactivePlot = FALSE)
> ##D 
> ##D #---------------------------------------------------------------------------#
> ##D 
> ##D ##########################
> ##D # Bivariate Moran's Ixy
> ##D ##########################   
> ##D 
> ##D cross <- eco.correlog(Z=eco[["P"]][,1], XY = eco[["XY"]], Y = eco[["P"]][, 1],
> ##D method = "CC", int= 2, smax=15)
> ##D # Interactive plot
> ##D eco.plotCorrelog(cross)
> ##D # ggplot2 plot
> ##D eco.plotCorrelog(cross, interactivePlot = FALSE)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.correlog", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.detrend")
> ### * eco.detrend
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.detrend
> ### Title: Detrending spatial data with polynomial interpolation
> ### Aliases: eco.detrend
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D data(eco2)
> ##D 
> ##D # original data
> ##D data1 <- matrix(eco2[["P"]][,1], 30, 30)
> ##D image(data1)
> ##D 
> ##D # original data + trend
> ##D data2 <- matrix(eco2[["P"]][,2], 30, 30)
> ##D image(data2)
> ##D 
> ##D # data detrending
> ##D data2.det <- eco.detrend(Z = eco2[["P"]][,2], XY =  eco2[["XY"]], degree =  1)
> ##D 
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accesed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D data2.det <- ecoslot.RES(data2.det)       # detrended data in slot RES
> ##D 
> ##D data2.det <- matrix(data2.det[,1], 30, 30)
> ##D image(data2.det)
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.detrend", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.format")
> ### * eco.format
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.format
> ### Title: Format tool for genetic data
> ### Aliases: eco.format
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D # Adding zeros
> ##D 
> ##D example <- as.matrix(genotype[1:10,])
> ##D mode(example) <- "character"
> ##D # example data
> ##D example                
> ##D recoded <- eco.format(example, ncod = 1, ploidy = 2, nout = 3)
> ##D # recoded data
> ##D recoded
> ##D 
> ##D 
> ##D # Tetraploid data, separating alleles with a "/"
> ##D tetrap <- as.matrix(example)
> ##D # simulated tetraploid example data
> ##D tetrap <- matrix(paste(example,example, sep = ""), ncol = ncol(example)) 
> ##D recoded <- eco.format(tetrap, ncod = 1, ploidy = 4, sep.out = "/")
> ##D # recoded data
> ##D recoded
> ##D 
> ##D # Example with a single character
> ##D ex <- c("A","T","G","C")
> ##D ex <- sample(ex, 100, rep= T)
> ##D ex <- matrix(ex, 10, 10)
> ##D colnames(ex) <- letters[1:10]
> ##D rownames(ex) <- LETTERS[1:10]
> ##D # example data
> ##D ex  
> ##D recoded <- eco.format(ex, ploidy = 1, nout = 1,  recode = "all", show.codes = TRUE) 
> ##D # recoded data 
> ##D recoded
> ##D 
> ##D 
> ##D # Example with two strings per cell and missing values:
> ##D ex <- c("Ala", "Asx", "Cys", "Asp", "Glu", "Phe", "Gly", "His", "Ile", 
> ##D "Lys", "Leu", "Met", "Asn", "Pro", "Gln", "Arg", "Ser", "Thr", 
> ##D "Val", "Trp")
> ##D ex1 <- sample(ex, 100, rep= T)
> ##D ex2 <- sample(ex, 100, rep= T)
> ##D ex3 <- paste(ex1, ex2, sep="")
> ##D missing.ex3 <- sample(1:100, 20)
> ##D ex3[missing.ex3] <-NA
> ##D ex4 <- matrix(ex3, 10, 10)
> ##D colnames(ex4) <- letters[1:10]
> ##D rownames(ex4) <- LETTERS[1:10]
> ##D # example data
> ##D ex4
> ##D recoded <- eco.format(ex4, ncod = 3, ploidy = 2, 
> ##D                       nout = 2, recode = "column")
> ##D # recoded data
> ##D recoded
> ##D 
> ##D # Example with a vector, following the latter example:
> ##D ex1 <- as.data.frame(ex1)
> ##D # example data
> ##D ex1
> ##D recoded <- eco.format(ex1, ploidy = 1, recode = "all")
> ##D # recoded data
> ##D recoded
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.format", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.formula")
> ### * eco.formula
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.formula
> ### Title: Formula construction for ecogen objects
> ### Aliases: eco.formula
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require(vegan)
> ##D data(eco.test)
> ##D 
> ##D # Note that in this example "Condition" is not replaced; 
> ##D # the function Condition has a special meaning in rda,
> ##D # indicating conditioning variables; in eco.formula it is only text.
> ##D 
> ##D form <- eco.formula(eco, P1 + P2 + P3 + U(A) ~ E1 + E2 + Condition(X+Y))
> ##D rda(form)
> ##D 
> ##D form2 <- eco.formula(eco, P1 + P2 + P3 + U(A) ~ E1 + E2 + X + Y)
> ##D lm(form2)
> ##D 
> ##D 
> ##D # parsing with magrittr
> ##D eco.formula(eco, P1 + P2 + P3 + U(A) ~ U(E) + Condition(X+Y)) %>% rda
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.formula", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.gsa")
> ### * eco.gsa
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.gsa
> ### Title: Global spatial analysis
> ### Aliases: eco.gsa
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D # Moran's I 
> ##D 
> ##D ### one test
> ##D con <- eco.weight(eco[["XY"]], method = "circle", d1 = 0, d2 = 2)
> ##D global <- eco.gsa(Z = eco[["P"]][, 1], con = con, method = "I", nsim = 200)
> ##D global
> ##D 
> ##D require(adegenet)
> ##D con2<-chooseCN(eco[["XY"]], type = 1, result.type = "listw", plot.nb = FALSE)
> ##D global <- eco.gsa(Z = eco[["P"]][, 1], con = con2, method = "I", nsim = 200)
> ##D global
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accesed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D # observed value
> ##D ecoslot.OBS(global)
> ##D 
> ##D # p-value
> ##D ecoslot.PVAL(global)
> ##D 
> ##D #----------------
> ##D # multiple tests
> ##D #----------------
> ##D data(eco3)
> ##D con <- eco.weight(eco3[["XY"]], method = "circle", d1 = 0, d2 = 500)
> ##D global <- eco.gsa(Z = eco3[["P"]], con = con, method = "I", nsim = 200)
> ##D global 
> ##D # Plot method for multivariable eco.gsa objects:
> ##D eco.plotGlobal(global)
> ##D 
> ##D #--------------------------------
> ##D # accessor use in multiple tests
> ##D #--------------------------------
> ##D 
> ##D ecoslot.MULTI(global)
> ##D 
> ##D 
> ##D #----------------------------------------
> ##D 
> ##D # Gearys's C 
> ##D 
> ##D con <- eco.weight(eco[["XY"]], method = "circle", d1 = 0, d2 = 2)
> ##D global.C <- eco.gsa(Z = eco[["P"]][, 1], con = con, method = "C", nsim = 200)
> ##D global.C
> ##D 
> ##D #----------------------------------------
> ##D 
> ##D # Bivariate's Moran's Ixy
> ##D 
> ##D con <- eco.weight(eco[["XY"]], method = "circle", d1 = 0, d2 = 2)
> ##D global.Ixy <- eco.gsa(Z = eco[["P"]][, 1], Y = eco[["E"]][, 1], 
> ##D con = con, method = "CC", nsim = 200)
> ##D global.Ixy
> ##D 
> ##D #----------------------------------------
> ##D 
> ##D # Join-count
> ##D 
> ##D ## using the allelic frequency matrix of an ecogen object. 
> ##D ## The data is diploid. Frequencies are transformed into counts
> ##D ## as ploidy * frequency_matrix:
> ##D 
> ##D Z = 2* eco[["A"]]
> ##D 
> ##D 
> ##D jc <- eco.gsa(Z[, 1], con = con, method = "JC")
> ##D eco.plotGlobal(jc)
> ##D 
> ##D # multiple tests
> ##D # using the first ten alleles of the matrix
> ##D global.JC <- eco.gsa(Z[, 1:10], ncod = 1, con = con, method = "JC", nsim = 99)
> ##D global.JC
> ##D # plot method for multivariable join-count
> ##D eco.plotGlobal(global.JC)
> ##D 
> ##D # counting joins between genotypes in the first locus the G matrix:
> ##D global.JC <- eco.gsa(Z = eco[["G"]][, 1], ploidy = 2, con = con, method = "JC", nsim = 99)
> ##D global.JC
> ##D eco.plotGlobal(global.JC)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.gsa", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.kin.loiselle")
> ### * eco.kin.loiselle
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.kin.loiselle
> ### Title: Obtention of the multilocus Loiselle's Fij matrix
> ### Aliases: eco.kin.loiselle
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D loiselle <- eco.kin.loiselle(eco)
> ##D loiselle[1:5, 1:5]
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.kin.loiselle", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.lagweight")
> ### * eco.lagweight
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.lagweight
> ### Title: Obtention of a list of spatial weights for classes defined by
> ###   inter-individual distances or nearest-neighbors
> ### Aliases: eco.lagweight
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eco.test)
> ##D 
> ##D # method sturges-smax: in this case, the program generates 
> ##D # classes using the Sturge's rule.  
> ##D # As smax and smin are undefined, the program uses the default
> ##D # options (smin = 0, and smax = maximum inter-individual distance)
> ##D classlist <- eco.lagweight(eco[["XY"]]) 
> ##D classlist
> ##D 
> ##D # method sturges-smax: idem, but smax = 16
> ##D classlist <- eco.lagweight(eco[["XY"]], smax=16) 
> ##D 
> ##D ## using smax <16 in this case generates empty classes, 
> ##D ## which is not allowed
> ##D 
> ##D # method sturges-smax: idem, but smin = 3
> ##D classlist <- eco.lagweight(eco[["XY"]], smin = 3, smax = 15)
> ##D 
> ##D # method sturges-smax: complete range, 
> ##D # and cummulative = TRUE (instead of using
> ##D # lower and upper limits for each class, only the upper is used in turn)
> ##D classlist <- eco.lagweight(eco[["XY"]], cummulative = TRUE)
> ##D 
> ##D # method n.classes-smax: complete range partitioned in 4 classes
> ##D classlist <- eco.lagweight(eco[["XY"]], nclass = 4)
> ##D 
> ##D # method n.classes-smax: idem, but smax =  15
> ##D classlist <- eco.lagweight(eco[["XY"]], nclass = 4, smax = 15)
> ##D 
> ##D # method int-smax: the complete range partitioned each <int> units
> ##D # of inter-individual distance
> ##D classlist <- eco.lagweight(eco[["XY"]], int = 2)
> ##D 
> ##D # method int-smax: idem, but smax = 15 and smin = 3
> ##D classlist <- eco.lagweight(eco[["XY"]], int = 2, smin = 3, smax = 15)
> ##D 
> ##D # method equal.size: n individuals in each class, 
> ##D # partitioning the complete range.
> ##D classlist <- eco.lagweight(eco[["XY"]], size = 1000)
> ##D 
> ##D ## In the latter example, as an inter-individual distance
> ##D ## appear more than one time (different individuals pairs, 
> ##D ## identical distances), with a size <700 the limits
> ##D ## of some classes cannot be defined, and this is not allowed
> ##D 
> ##D # method equal.size: n individuals in each class, 
> ##D # but smax = 15
> ##D classlist <- eco.lagweight(eco[["XY"]], size = 1000, smax = 15)
> ##D 
> ##D # method kmax: sequence from k = 1 to k = n, in this case, n = 3
> ##D classlist <- eco.lagweight(eco[["XY"]], kmax = 3)
> ##D 
> ##D # method kmax: idem, but elements self-included
> ##D # (i.e., the pairs i-i, for all individuals i, are included)
> ##D classlist <- eco.lagweight(eco[["XY"]], kmax = 3, self = TRUE)
> ##D 
> ##D # method seqvec: a vector with the breaks is used
> ##D vec <- seq(0, 10, 2)
> ##D classlist <- eco.lagweight(eco[["XY"]], seqvec = vec)
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accessed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.BREAKS(classlist) # information about breaks. It includes the upper and lower limits
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.lagweight", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.lmtree")
> ### * eco.lmtree
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.lmtree
> ### Title: Fitting Multiple Linear Regression models by stepwise AIC
> ###   selection and Multiple Classification and Regression Trees via party
> ### Aliases: eco.lmtree
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D # mlm additive model
> ##D mod <- eco.lmtree(df1 = eco[["P"]], df2 = eco[["E"]], 
> ##D analysis = "mlm")                                 
> ##D mod
> ##D summary(mod)
> ##D 
> ##D # mctree additive model
> ##D mod <- eco.lmtree(df1 = eco[["P"]], df2 = eco[["E"]], 
> ##D analysis = "mctree", fact = eco[["S"]]$pop) 
> ##D 
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accessed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D summary(mod)
> ##D 
> ##D ecoslot.FREQUENCIES(mod)        # slot FREQUENCIES
> ##D 
> ##D # frequency table with counts of individuals in populations x terminal nodes
> ##D tabfreq <- do.call(cbind, ecoslot.FREQUENCIES(mod))
> ##D namestab <- lapply(ecoslot.FREQUENCIES(mod), ncol)
> ##D namestab <- lapply(namestab, rep)
> ##D namestab <- rep(names(namestab), namestab)
> ##D colnames(tabfreq) <- namestab
> ##D tabfreq
> ##D 
> ##D # mlm custom model
> ##D mymod <- "E1+E2*E3"
> ##D mod <- eco.lmtree(df1 = eco[["P"]], df2 = eco[["E"]], 
> ##D analysis = "mlm", mod.class = mymod)            
> ##D summary(mod)
> ##D 
> ##D # mctree custom model
> ##D mod <- eco.lmtree(df1 = eco[["P"]], df2 = eco[["E"]], 
> ##D analysis = "mctree", mod.class = mymod, fact = eco[["S"]]$pop)   
> ##D  
> ##D                       
> ##D summary(mod)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.lmtree", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.lmtree.mctree-summary")
> ### * eco.lmtree.mctree-summary
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summary,eco.mlm-method
> ### Title: Summary for eco.lmtree output
> ### Aliases: summary,eco.mlm-method summary,eco.lmtree-method
> ###   summary,eco.mctree-method
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D #' mod <- eco.lmtree(DF1 = eco$P, DF2 = eco$E, 
> ##D analysis = "mlm")                                    
> ##D summary(mod)                                    #summary for "mlm" analysis
> ##D 
> ##D mod <- eco.lmtree(DF1 = eco$P, DF2 = eco$E,
> ##D analysis = "mctree", fact = eco$S$structure)               
> ##D summary(mod)                                    #summary for "mctree" analysis
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.lmtree.mctree-summary", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.lsa")
> ### * eco.lsa
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.lsa
> ### Title: Local spatial analysis
> ### Aliases: eco.lsa
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D #---------------------------------------------------------------------------#
> ##D 
> ##D 
> ##D #####################
> ##D # LOCAL MORAN'S I
> ##D #####################
> ##D 
> ##D DETAILED EXAMPLE
> ##D 
> ##D #-------------------------
> ##D # TESTING PHENOTYPIC DATA-
> ##D #-------------------------
> ##D 
> ##D set.seed(10)
> ##D 
> ##D # test for a single variable---------------------------------
> ##D #computing weights
> ##D 
> ##D con <- eco.weight(eco[["XY"]], method = "knearest",  k = 4, row.sd = TRUE) 
> ##D # row standardized weights = TRUE
> ##D 
> ##D # test for the first trait of the data frame P 
> ##D localmoran <- eco.lsa(eco[["P"]][, 1], con, method = "I", nsim = 99)     
> ##D 
> ##D # "rankplot" graph
> ##D eco.plotLocal(localmoran)
> ##D 
> ##D # test for several variables---------------------------------
> ##D 
> ##D # ordering the factor "pop" in increasing order and the object "eco"
> ##D # in relation to this ordered factor prior to the multivariate analysis.
> ##D # This step is important for "localplot" graphs.
> ##D 
> ##D eco <- eco[order(eco[["S"]][,1])]
> ##D 
> ##D #computing weights with the ordered object
> ##D 
> ##D con <- eco.weight(eco[["XY"]], method = "knearest",  k = 4, row.sd = TRUE) 
> ##D # row standardized weights = TRUE
> ##D 
> ##D all.traits <- eco.lsa(eco[["P"]], con, method = "I", nsim = 99)     
> ##D 
> ##D # Plot of the phenotypic spatial patterns
> ##D 
> ##D # "rasterplot" graph 
> ##D eco.plotLocal(all.traits)
> ##D 
> ##D # in grey: non significant results (P > 0.05)
> ##D # set significant = FALSE for showing significant and no significant results
> ##D eco.plotLocal(all.traits, significant = FALSE)
> ##D 
> ##D # single plots using "rankplot" graphs
> ##D all.single.traits <- eco.lsa(eco[["P"]],con, method = "I", nsim = 99, multi="list")
> ##D eco.plotLocal(all.single.traits)
> ##D 
> ##D # removing legends for a better visualization
> ##D eco.plotLocal(all.single.traits, legend = FALSE)
> ##D # - individual plots support ggplot2 sintax (plot equivalent to the previous):
> ##D eco.plotLocal(all.single.traits) + ggplot2::theme(legend.position="none")
> ##D 
> ##D 
> ##D #-------------------------
> ##D # TESTING GENOTYPIC DATA-
> ##D #-------------------------
> ##D 
> ##D # eco[["A"]] is a matrix with the genetic data of "eco"
> ##D # as frequencies for each allele in each individual.
> ##D 
> ##D head(eco[["A"]])      # head of the matrix - 40 alleles
> ##D 
> ##D # ordering the factor "pop" in increasing order and the object "eco"
> ##D # in relation to this ordered factor prior to the multivariate analysis.
> ##D # This step is important for "localplot" graphs
> ##D 
> ##D data(eco.test) # for security this resets the data (unordered)
> ##D 
> ##D eco <- eco[order(eco[["S"]][,1])] # ordering
> ##D 
> ##D # computing weights with the ordered object
> ##D 
> ##D con <- eco.weight(eco[["XY"]], method = "knearest",  k = 4, row.sd = TRUE) 
> ##D # row standardized weights = TRUE
> ##D 
> ##D # test for a single allele
> ##D localmoran.geno <-  eco.lsa(eco[["A"]][, 32], con, method = "I", nsim = 99)
> ##D 
> ##D # test for several alleles -  40 alleles (it runs in less than 1 min 
> ##D # for 99 simulations per allele;  999 simulations takes ~ 11 s per allele, 
> ##D # less than 8 min in total.) 
> ##D all.alleles <-  eco.lsa(eco[["A"]], con, method = "I", nsim = 99)
> ##D 
> ##D # plot all alleles to get an overview of the spatial patterns
> ##D eco.plotLocal(all.alleles)
> ##D 
> ##D # in grey: non significant results (P > 0.05)
> ##D # set significant = FALSE for showing significant and no significant results
> ##D eco.plotLocal(all.alleles, significant = FALSE)
> ##D 
> ##D # counting individuals with P < 0.05 for each allele (5 * 225 /100 ~  12 significant tests 
> ##D # by random)
> ##D signif <- apply(ecoslot.PVAL(all.alleles), 2, function(x) sum (x < 0.05))
> ##D 
> ##D # filtering alleles, loci with > 12 significant individual tests
> ##D 
> ##D A.local <- eco[["A"]][, signif > 12]     #filtered matrix
> ##D 
> ##D all.alleles.f <-  eco.lsa(eco[["A"]][, signif > 12] , con, method = "I", nsim = 99)
> ##D 
> ##D 
> ##D # Plot of the genotypic spatial patterns using "localplot" graphs
> ##D 
> ##D eco.plotLocal(all.alleles.f)
> ##D 
> ##D 
> ##D ## using "rankplot" graphs
> ##D 
> ##D all.sf <- eco.lsa(A.local,  2, eco.lsa, con, method = "I", nsim = 99, multi = "list")
> ##D eco.plotLocal(all.sf, legend = FALSE) 
> ##D 
> ##D 
> ##D #####################
> ##D # GETIS-ORD'S G*
> ##D #####################
> ##D 
> ##D con<- eco.weight(eco[["XY"]], method = "knearest",  k = 4, self = TRUE) # self = TRUE for G*
> ##D getis.ak <- eco.lsa(eco[["P"]][, 1], con, method = "G*", nsim = 99, adjust = "none")
> ##D getis.ak
> ##D 
> ##D ### to plot the results, the function "eco.lsa" calls "eco.rankplot"
> ##D ### (see ?eco.rankplot) when test = "permutation" and "eco.forestplot" (see ?eco.forestplot)
> ##D ###  when test = "bootstrap"
> ##D 
> ##D p <- eco.plotLocal(getis.ak)      # rankplot graph
> ##D p    #  points with colors of the color-scale:  
> ##D      #  points with P < 0.05. Yellow points : points with P > 0.05
> ##D p <- eco.plotLocal(getis.ak, significant = FALSE)  
> ##D p    # all points have a color of the color-scale 
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accessed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.OUT(getis.ak)
> ##D 
> ##D ## bootstrap example
> ##D getis.akb <- eco.lsa(eco[["P"]][, 1], con, method = "G*", nsim = 99, test = "bootstrap")
> ##D p <- eco.plotLocal(getis.akb)      # forestplot graph
> ##D 
> ##D p2 <- eco.plotLocal(getis.akb, interactivePlot = FALSE)  
> ##D p2 + ggplot2::theme_bw()   # the plot can be modified with ggplot2
> ##D                           # In this case, the background is modified  (white color)
> ##D 
> ##D #---------------------------------------------------------------------------#
> ##D  
> ##D #####################
> ##D # GETIS-ORD'S G
> ##D #####################
> ##D 
> ##D con <- eco.weight(eco[["XY"]], method = "knearest", k = 4) 
> ##D # self = FALSE for G
> ##D getis <- eco.lsa(eco[["P"]][, 1], con, method = "G", nsim = 99)
> ##D eco.plotLocal(getis)
> ##D 
> ##D #---------------------------------------------------------------------------#
> ##D 
> ##D #####################
> ##D # LOCAL GEARY'S C
> ##D #####################
> ##D 
> ##D con<- eco.weight(eco[["XY"]], method = "knearest",  k = 4, row.sd = TRUE) 
> ##D # row standardized weights = TRUE
> ##D localgeary <- eco.lsa(eco[["P"]][, 1], con, method = "C", nsim = 99, adjust = "none")
> ##D eco.plotLocal(localgeary)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.lsa", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.malecot")
> ### * eco.malecot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.malecot
> ### Title: Global and local kinship analysis
> ### Aliases: eco.malecot
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D # ---global analysis---
> ##D 
> ##D globaltest <- eco.malecot(eco=eco, method = "global", smax=10,
> ##D                          size=1000)
> ##D eco.plotCorrelog(globaltest)    # Significant mean class coancestry classes at   
> ##D                     # individual level (alpha = 0.05, 
> ##D                     # out of the red area), 
> ##D                     # and family-wise P corrected values (red-blue
> ##D                     # points, indicated in the legend)
> ##D 
> ##D # ecoslot.SP(globaltest) contains:
> ##D # - the slope (bhat) and values with confidence intervals
> ##D #  of the regression reg = kinship ~ ln(distance_between_individuals)
> ##D #- A Mantel test result for assesing the relation between
> ##D #  between  kinship and ln(distance_between_individuals)
> ##D #- A cubic interpolation between the residuals of reg and 
> ##D #  ln(distance_between_individuals)
> ##D #- the sp statistic and its confidence interval
> ##D 
> ##D # ecoslot.OUT(globaltest) contains:
> ##D # - In permutation case, the values of mean and log-mean distance    
> ##D #   classes; observed class value; expected + alternative + P value,
> ##D #   the bootstrap null confidence intervals and 
> ##D #   jackknife statistics (jackknifed mean, jackknifed SD, and
> ##D #                         CI for the class statistic)
> ##D 
> ##D # - In bootstrap case, the values of mean and log-mean distance
> ##D #   classes;the bootstrap null confidence intervals and 
> ##D #   jackknife statistics (jackknifed mean, jackknifed SD, and
> ##D #                         CI for the class statistic)
> ##D 
> ##D 
> ##D # A directional approach based in bearing correlograms, 30 degrees
> ##D globaltest_30 <- eco.malecot(eco=eco, method = "global", smax=10,
> ##D                          size=1000, angle = 30)
> ##D eco.plotCorrelog(globaltest) 
> ##D 
> ##D #----------------------------------------------------------#
> ##D # ---local analysis---
> ##D 
> ##D 
> ##D # (using the spatial weights). 
> ##D 
> ##D # ---local analysis with k nearest neighbors---
> ##D 
> ##D 
> ##D 
> ##D localktest <- eco.malecot(eco=eco, method = "local",
> ##D                          type = "knearest", kmax = 5, 
> ##D                          adjust = "none")
> ##D eco.plotLocal(localktest)
> ##D 
> ##D 
> ##D # ---local analysis with radial distance---
> ##D 
> ##D localdtest <- eco.malecot(eco=eco, method = "local",
> ##D                         type = "radialdist", smax = 3, 
> ##D                         adjust = "none")
> ##D                         
> ##D eco.plotLocal(localdtest)                    # rankplot graphic (see ?"eco.rankplot")
> ##D 
> ##D                                          # Significant values
> ##D                                          # in blue-red scale, 
> ##D                                          # non significant 
> ##D                                          # values in yellow
> ##D 
> ##D eco.plotLocal(localktest, significant = FALSE)    # significant and non
> ##D                                               # signficant values
> ##D                                               # in blue-red scale
> ##D 
> ##D # The slot OUT of localktest (ecoslot.OUT(localktest)) and localdtest 
> ##D # (ecoslot.OUT(localdtest)) contains:
> ##D # - the mean distance per individual, observed value of the
> ##D #   statistic, expected + alternative + P value + null hypotesis
> ##D #   confidence intervals,  or boostrap confidence intervals in 
> ##D #   permutation or bootstrap cases, respectively.
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.malecot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.mantel")
> ### * eco.mantel
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.mantel
> ### Title: Mantel and partial Mantel tests, with truncation option
> ### Aliases: eco.mantel
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D ### Ordinary Mantel test ###
> ##D eco.mantel(d1 = dist(eco[["P"]]), d2 = dist(eco[["E"]]), nsim = 99)  
> ##D 
> ##D ### Partial Mantel test ###
> ##D pm <- eco.mantel(d1 = dist(eco[["P"]]), d2 = dist(eco[["E"]]), 
> ##D dc = dist(eco[["XY"]]), nsim = 99)                               
> ##D 
> ##D ### Truncated Mantel test ###
> ##D # checking threshold in a correlogram:
> ##D corm <- eco.cormantel(M = dist(eco[["P"]]), XY = eco[["XY"]], nsim = 99)
> ##D eco.plotCorrelog(corm)
> ##D # Correlation is around 0 when distance between points is > 5
> ##D 
> ##D # creating a weights object for truncation
> ##D con <- eco.weight(eco@XY, method="circle", d2=5)
> ##D # compute a truncated mantel test
> ##D eco.mantel(dist(eco[["P"]]), dist(eco[["XY"]]), con=con)
> ##D 
> ##D ### Directional Mantel test ###
> ##D # analyzing with a Mantel test, in a direction of 35 degrees counterclockwise from E.
> ##D con2 <- eco.bearing(XY = eco[["XY"]], theta = 37)
> ##D eco.mantel(dist(eco[["P"]]), dist(eco[["XY"]]), con = con2)
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accessed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.OBS(pm)     # slot OBS (observed value)
> ##D ecoslot.PVAL(pm)    # slot PVAL (P-value) 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.mantel", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.merge")
> ### * eco.merge
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.merge
> ### Title: Merging two ecogen objects. Ordering the rows of an ecogen
> ###   object according to the rows of another
> ### Aliases: eco.merge
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eco.test)
> ##D eco
> ##D eco1 <- eco[2:20]
> ##D merged <- eco.merge(eco, eco1)
> ##D merged
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.merge", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.pairtest")
> ### * eco.pairtest
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.pairtest
> ### Title: Kruskall - Wallis + Wilcoxon (Mann-Whitney U) and aov +
> ###   Tukey-HSD tests for an ecogen object
> ### Aliases: eco.pairtest
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eco3)
> ##D wil <- eco.pairtest(eco = eco3, df = "P", x = "structure")
> ##D wil
> ##D wil <- eco.pairtest(eco = eco3,df = "E", x = "structure")
> ##D wil
> ##D wil <- eco.pairtest(eco = eco3, df = "P", x = "structure", only.p = FALSE)
> ##D wil
> ##D wil <- eco.pairtest(eco = eco3,df = "P", x = "structure", test = "tukey")
> ##D wil
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.pairtest", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.plotWeight")
> ### * eco.plotWeight
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.plotWeight
> ### Title: Plot for a connection network
> ### Aliases: eco.plotWeight
> 
> ### ** Examples
> 
> # see the examples in the function eco.weight:
> # ?eco.weight
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.plotWeight", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.post.geneland")
> ### * eco.post.geneland
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.post.geneland
> ### Title: Log posterior probability plot for Geneland repetitions with
> ###   fixed K
> ### Aliases: eco.post.geneland
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require("Geneland")
> ##D data(eco.test)
> ##D 
> ##D # We create a folder in the working directory for the results and 
> ##D # save the data frames of the object "eco" in the format required
> ##D # by Geneland:
> ##D 
> ##D path.1 <- getwd()
> ##D path <- paste(path.1,"/test/", sep="")
> ##D dir.create(path) 
> ##D setwd(path)
> ##D ecogen2geneland(eco, ploidy = 2)
> ##D 
> ##D # Auxiliar function for running some repetitions with fixed K = 4.
> ##D # Each repetition is saved in the folder "test":
> ##D simul <- function(i) {
> ##D  path <- getwd()
> ##D path <- paste(path,"/",i, sep = "")
> ##D dir.create(path) 
> ##D MCMC(coordinates = read.table("XY.txt"), 
> ##D 		 geno.dip.codom = read.table("G.txt"), 
> ##D 		 varnpop = TRUE, npopmin = 4, npopmax = 4, spatial = TRUE, 
> ##D 		 freq.model = "Correlated", nit = 500, thinning = 10,
> ##D 		 path.mcmc = path)
> ##D }
> ##D 
> ##D # 5 repetitions with K = 4 
> ##D lapply(1:5, simul)
> ##D 
> ##D # Check that in the folder "test" are the simulated result.
> ##D # Your results must have that appearance.
> ##D 
> ##D # Plot of the repetition order number vs the corresponding
> ##D # posterior probability, with a burn-in of 10 mcmc:
> ##D eco.post.geneland(5, 10)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.post.geneland", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.rasterplot")
> ### * eco.rasterplot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.rasterplot
> ### Title: Rasterplot graphs
> ### Aliases: eco.rasterplot
> 
> ### ** Examples
> 
> 
>  ## Not run: 
> ##D data(eco.test)
> ##D require(ggplot2)
> ##D 
> ##D # using the ecogen object "eco" to perform a multiple-lsa
> ##D con <- eco.weight(eco[["XY"]], method = "knearest", k = 4, row.sd = TRUE)
> ##D test.lsa <- eco.lsa(eco[["P"]], con = con, method = "I", nsim = 99, multi = "matrix")
> ##D 
> ##D # the plot method for this object based in ggplot2, is a resterplot
> ##D eco.plotLocal(test.lsa, multi = "ggplot2")
> ##D 
> ##D # adding a factor
> ##D test.lsa <- eco.lsa(eco[["P"]], con = con, method = "I",
> ##D nsim = 99, multi = "matrix", pop = eco[["S"]][,1])
> ##D eco.plotLocal(test.lsa, multi = "ggplot2")
> ##D 
> ##D # The generic rasterplot method requires a data matrix, and, as option, a condition 
> ##D # and a filter matrix. The condition is an expression, containing the word "filter" and 
> ##D # logical elements, e.g., "filter < 50", "filter <50 || filter > 2", etc. ). 
> ##D # Filter is used as a logical matrix (TRUE-FALSE, in relation to the passed condition),
> ##D # for filtering the data. If a condition is passed but not a filter matrix, the condition
> ##D # is applied over the data matrix, also using the word "filter". 
> ##D # Internally, the multi.lsa plot uses three fundamental elements. 
> ##D # - a data matrix: in the example, ecoslot.OBS(test.lsa)
> ##D # - a filter matrix: in the example, ecoslt.PVAL(test.lsa); i.e., 
> ##D # the data matrix will be filtered by P-value using the third element, an expresion.
> ##D # - an expression: in the example: "filter < 0.05"
> ##D  
> ##D  # by combining the three elements, the multivariate plot can be manually constructed:
> ##D  my.plot <- eco.rasterplot(x= ecoslot.OBS(test.lsa), 
> ##D  filter = ecoslot.PVAL(test.lsa), condition = "filter < 0.05")
> ##D  my.plot
> ##D  
> ##D  
> ##D  # add population
> ##D  my.plot <- eco.rasterplot(x= ecoslot.OBS(test.lsa), 
> ##D  filter = ecoslot.PVAL(test.lsa), 
> ##D  condition = "filter < 0.05", grp = ecoslot.POP(test.lsa))
> ##D  my.plot
> ##D  
> ##D  
> ##D  # extra manipulation with ggplot2 graphs (ggplot2 commands allowed by rasterplot)
> ##D  my.plot <- eco.rasterplot(x= ecoslot.OBS(test.lsa), 
> ##D  filter = ecoslot.PVAL(test.lsa), condition = "filter < 0.05",
> ##D  interactivePlot = FALSE)
> ##D  my.plot
> ##D  
> ##D  
> ##D  ## rotate plot
> ##D  
> ##D  my.plot + coord_flip()
> ##D  
> ##D  ## change design
> ##D  my.plot + theme_grey()
> ##D  
> ##D  
> ##D  # using the data as filter
> ##D  eco.rasterplot(x= ecoslot.OBS(test.lsa), filter = ecoslot.OBS(test.lsa), 
> ##D  condition = "filter > 0 & filter < 3")
> ##D  
> ##D  
> ##D  # example of bad syntax (incorrect use of && over matrices)
> ##D  eco.rasterplot(x= ecoslot.OBS(test.lsa), filter = ecoslot.OBS(test.lsa), 
> ##D  condition = "filter > 0 && filter < 3")
> ##D  
> ##D  
> ## End(Not run)
>  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.rasterplot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.rbind")
> ### * eco.rbind
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.rbind
> ### Title: Combining ecogen objects by row
> ### Aliases: eco.rbind
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D # split the object "eco" into a list of ecogen objects by population
> ##D x <- eco.split(eco, "pop", asList = TRUE)
> ##D 
> ##D # re-bind the objects
> ##D eco.r <- eco.rbind(eco)
> ##D 
> ##D # create a new objects with the first and second population
> ##D eco.r <- eco.rbind(x[[1]], x[[3]])
> ##D 
> ##D # duplicated row names are not allowed by eco.rbind with default options
> ##D eco2 <- eco
> ##D eco.rbind(eco, eco2)
> ##D 
> ##D eco.rbind(eco, eco2,check_rownames = FALSE)
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.rbind", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.remove")
> ### * eco.remove
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.remove
> ### Title: Creating an updated ecogen object by removing results of the
> ###   slot OUT
> ### Aliases: eco.remove
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D variog <- eco.variogram(eco[["P"]][, 1], eco[["XY"]])
> ##D 
> ##D # the assignment of values can be made with the corresponding accessors,
> ##D # using the generic notation of EcoGenetics 
> ##D # (<ecoslot.> + <name of the slot> + <name of the object>).
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.OUT(eco) <- variog         
> ##D we.are.numbers <- c(1:10)
> ##D we.are.characters <- c("John Coltrane", "Charlie Parker")
> ##D ecoslot.OUT(eco) <- list(we.are.numbers, we.are.characters)
> ##D ecoslot.OUT(eco)
> ##D eco <- eco.remove(eco, we.are.numbers)
> ##D ecoslot.OUT(eco)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.remove", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.slide.con")
> ### * eco.slide.con
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.slide.con
> ### Title: Sliding a window along a connection network
> ### Aliases: eco.slide.con
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco2)
> ##D myMatrix <- eco2[["P"]]
> ##D con <- eco.weight(XY = eco2[["XY"]], method = "knearest", k = 5)
> ##D result <- eco.slide.con(myMatrix, con, function(x) mean(x, na.rm = TRUE))
> ##D 
> ##D image(matrix(myMatrix[, 1], 30, 30)) # original image
> ##D image(matrix(result[, 1], 30, 30)) # smoothed image
> ##D 
> ##D data(eco3)
> ##D myMatrix2 <- eco3[["P"]]
> ##D con <- eco.weight(XY = eco3[["XY"]], method="knearest", k = 5)
> ##D eco.plotWeight(con)
> ##D # smoothing values in myMatrix2 using the connection network:
> ##D result <- eco.slide.con(myMatrix2, con, function(x) mean(x, na.rm = TRUE))
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.slide.con", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.slide.matrix")
> ### * eco.slide.matrix
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.slide.matrix
> ### Title: Sliding window for matrix data
> ### Aliases: eco.slide.matrix
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D ras <- matrix(eco[["P"]][, 1], 15, 15)
> ##D image(ras)
> ##D ras.square <- eco.slide.matrix(ras, 1, 1, mean, "square")
> ##D image(ras.square)
> ##D 
> ##D # or allowing more control over the function:
> ##D ras.square <- eco.slide.matrix(ras, r = 3, slide = 1, function(x) mean(x, na.rm = TRUE), "square")
> ##D image(ras.square)
> ##D 
> ##D # sliding a circle:
> ##D ras.circle <- eco.slide.matrix(ras, r = 3, slide = 1, mean, "circle", within = FALSE)
> ##D image(ras.circle) 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.slide.matrix", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.split")
> ### * eco.split
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.split
> ### Title: Splitting an ecogen object by group
> ### Aliases: eco.split
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eco3)
> ##D eco3
> ##D 
> ##D 
> ##D # list of objects
> ##D x <- eco.split(eco3, "structure", asList = TRUE)
> ##D 
> ##D 
> ##D # rebinding
> ##D eco.bind <- eco.rbind(x)
> ##D 
> ##D 
> ##D # note that different subsets can also be created
> ##D S1.3 <- eco.rbind(x[[1]], x[[3]])
> ##D 
> ##D 
> ##D # split and create objects with prefix "eco3"
> ##D eco.split(eco3,"structure", asList = FALSE)
> ##D 
> ##D 
> ##D # split and create objects with prefix "newObjects"
> ##D eco.split(eco3,"structure", "newObjects", asList = FALSE) 
> ##D 
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.split", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.subset")
> ### * eco.subset
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.subset
> ### Title: Subsetting an ecogen object by group
> ### Aliases: eco.subset
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eco3)
> ##D eco3
> ##D eco.sub <-eco.subset(eco3,"structure", 1) 
> ##D eco.sub
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.subset", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.theilsen")
> ### * eco.theilsen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.theilsen
> ### Title: Theil-sen regression for a raster time series
> ### Aliases: eco.theilsen
> 
> ### ** Examples
> 
> ## Not run: 
> ##D require("raster")
> ##D set.seed(6)
> ##D 
> ##D temp <- list()
> ##D for(i in 1:100) {
> ##D temp[[i]] <- runif(36,-1, 1)
> ##D temp[[i]] <- matrix(temp[[i]], 6, 6)
> ##D temp[[i]] <- raster(temp[[i]])
> ##D }
> ##D 
> ##D temp <- brick(temp)
> ##D 
> ##D 
> ##D writeRaster(temp,"temporal.tif", overwrite=T)
> ##D rm(temp)
> ##D ndvisim <- brick("temporal.tif")
> ##D 
> ##D date <- seq(from = 1990.1, length.out = 100, by = 0.2)
> ##D 
> ##D eco.theilsen(ndvisim, date)
> ##D 
> ##D pvalue <- raster("pvalue.tif")
> ##D slope <- raster("slope.tif")
> ##D par(mfrow = c(1, 2))
> ##D plot(pvalue, main = "p-value")
> ##D plot(slope, main = "slope")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.theilsen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.variogram")
> ### * eco.variogram
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.variogram
> ### Title: Empirical variogram
> ### Aliases: eco.variogram
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D variog <- eco.variogram(Z = eco[["P"]][, 2],XY =  eco[["XY"]])
> ##D plot(variog)
> ##D 
> ##D # variogram plots support the use of ggplot2 syntax
> ##D require(ggplot2)
> ##D variogplot <- eco.plotCorrelog(variog) + theme_bw() + theme(legend.position="none")
> ##D variogplot
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accessed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.OUT(variog)        # slot OUT
> ##D ecoslot.BREAKS(variog)     # slot BREAKS
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.variogram", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("eco.weight")
> ### * eco.weight
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.weight
> ### Title: Spatial weights
> ### Aliases: eco.weight
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco3)
> ##D 
> ##D # 1)  "circle" method
> ##D 
> ##D con <- eco.weight(eco3[["XY"]], method = "circle", d1 = 0, d2 = 500)
> ##D 
> ##D 
> ##D #---- Different plot styles for the graph ----#
> ##D 
> ##D # simple
> ##D eco.plotWeight(con, type = "simple") 
> ##D             
> ##D # igraph
> ##D eco.plotWeight(con, type = "igraph", group = eco3[["S"]]$structure)
> ##D 
> ##D # network (interactive)
> ##D ## click in a node to see the label
> ##D eco.plotWeight(con, type = "network", bounded = TRUE, group = eco3[["S"]]$structure)
> ##D 
> ##D # edgebundle (interactive)
> ##D ## in the following plot, the assignment a group factor, 
> ##D ## generates clustered nodes.
> ##D ## hover over the nodes to see the individual connections
> ##D eco.plotWeight(con, type = "edgebundle", fontSize=8, group = eco3[["S"]]$structure)
> ##D 
> ##D 
> ##D # 2) "knearest" method
> ##D 
> ##D con <- eco.weight(eco3[["XY"]], method = "knearest", k = 10)
> ##D eco.plotWeight(con) 
> ##D eco.plotWeight(con, type = "network", bounded = TRUE, group = eco3[["S"]]$structure)
> ##D 
> ##D # 3)  "inverse" method
> ##D ## scale dependent. In the example, the original coordinates (in km) are converted into m
> ##D con <- eco.weight(eco3[["XY"]]/1000, method = "inverse", max.sd = TRUE, p = 0.1)
> ##D con
> ##D eco.plotWeight(con)
> ##D 
> ##D # 4) "circle.inverse" method
> ##D con <- eco.weight(eco3[["XY"]], method = "circle.inverse", d2 = 1000)
> ##D con
> ##D eco.plotWeight(con)
> ##D 
> ##D # 5) "exponential" method
> ##D ## scale dependent. In the example, the original coordinates (in km) are converted into m
> ##D con <- eco.weight(eco3[["XY"]]/1000, method = "exponential", max.sd = TRUE, alpha = 0.1)
> ##D eco.plotWeight(con)
> ##D 
> ##D # 6) "circle.exponential" method
> ##D con <- eco.weight(eco3[["XY"]], method = "circle.exponential", d2 = 2000)
> ##D con
> ##D eco.plotWeight(con)
> ##D 
> ##D 
> ##D # 7) CUSTOM WEIGHT MATRIX
> ##D 
> ##D ## An eco.weight object can be created with a custom W matrix. In this case,
> ##D ## the rows and the columns of W (weight matrix) must have names, 
> ##D ## that must coincide (also in order) with the name of the XY (position) matrix.
> ##D 
> ##D require(igraph)
> ##D ## this example generates a network with the package igraph
> ##D tr <- make_tree(40, children = 3, mode = "undirected")
> ##D plot(tr, vertex.size = 10, vertex.label = NA) 
> ##D 
> ##D ## conversion from igraph to weight matrix 
> ##D weights <- as.matrix(as_adj(tr))
> ##D 
> ##D ## weight matrix requires named rows and columns
> ##D myNames <- 1:nrow(weights)
> ##D rownames(weights) <- colnames(weights) <-  myNames
> ##D 
> ##D ## extract coordinates from the igraph object 
> ##D coord <- layout.auto(tr)
> ##D rownames(coord) <- myNames
> ##D plot(layout.auto(tr))
> ##D 
> ##D ## custom weight object
> ##D customw <- eco.weight(XY = coord, W = weights)
> ##D 
> ##D ## simple plot of the object
> ##D eco.plotWeight(customw, type = "simple")
> ##D 
> ##D ## create a vector with groups to have coloured plots
> ##D myColors <- c(rep(1,13), rep(2, 9), rep(3, 9), rep(4, 9))
> ##D 
> ##D eco.plotWeight(customw, type = "igraph",group = myColors)
> ##D 
> ##D ## in the following plot, the argument bounded is set to FALSE, 
> ##D ## but if you have many groups, it probably should be set to TRUE.
> ##D # click in a node to see the label
> ##D eco.plotWeight(customw,type = "network", bounded = FALSE, group = myColors)
> ##D 
> ##D ## in the following plot, the assignment a group factor, 
> ##D # generates clustered nodes.
> ##D # hover over the name of the nodes to see the individual connections
> ##D eco.plotWeight(customw,  type = "edgebundle", group = myColors)
> ##D 
> ##D 
> ##D #### CONVERSION FROM LISTW OBJECTS #####
> ##D require(adegenet)
> ##D # Delaunay triangulation
> ##D temp <-chooseCN(eco3[["XY"]], type = 1, result.type = "listw", plot.nb = FALSE)
> ##D con <- eco.listw2ew(temp)
> ##D eco.plotWeight(con, "network", bounded = TRUE, group = eco3[["S"]]$structure)
> ##D 
> ##D 
> ##D #-----------------------
> ##D # ACCESSORS USE EXAMPLE
> ##D #-----------------------
> ##D 
> ##D # the slots are accessed with the generic format 
> ##D # (ecoslot. + name of the slot + name of the object). 
> ##D # See help("EcoGenetics accessors")
> ##D 
> ##D ecoslot.METHOD(con)        # slot METHOD
> ##D ecoslot.PAR(con)           # slot PAR
> ##D ecoslot.PAR.VAL(con)       # slot PAR.VAL
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("eco.weight", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ecogen")
> ### * ecogen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ecogen
> ### Title: Creating a new ecogen object
> ### Aliases: ecogen
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D # Example with G data of class "data.frame", corresponding to
> ##D # microsatellites of a diploid organism:
> ##D data(eco.test)
> ##D eco <- ecogen(XY = coordinates, P = phenotype, G = genotype,
> ##D E = environment, S = structure)
> ##D 
> ##D # Example with G data of class "data.frame", corresponding to a
> ##D # presence - absence molecular marker:
> ##D dat <- sample(c(0,1),100,rep = TRUE)
> ##D dat <- data.frame(matrix(dat,10,10))
> ##D eco <- ecogen(G = dat, type = "dominant")
> ##D 
> ##D 
> ##D # DINAMIC ASSIGNMENT WITH ACCESSORS AND "[["
> ##D 
> ##D eco <- ecogen(XY = coordinates, P = phenotype)
> ##D eco
> ##D 
> ##D ecoslot.G(eco, order.G = TRUE) <- genotype
> ##D 
> ##D # this is identical to
> ##D eco[["G", order.G=TRUE]] <- genotype
> ##D 
> ##D ecoslot.E(eco) <- environment
> ##D 
> ##D # this is identical to
> ##D eco[["E"]] <- environment
> ##D 
> ##D #----------------------------------------------------------
> ##D # See additional examples in help("EcoGenetics accessors")
> ##D #----------------------------------------------------------
> ##D 
> ##D # Storing data in the slot OUT
> ##D 
> ##D  singers <- c("carlos_gardel", "billie_holiday")
> ##D  
> ##D ecoslot.OUT(eco) <- singers
> ##D  
> ##D # Storing several datasets
> ##D 
> ##D golden.number <- (sqrt(5) + 1) / 2
> ##D ecoslot.OUT(eco) <- list(singers, golden.number)    # several objects must be passed as a list
> ##D 
> ##D # this is identical to:
> ##D 
> ##D eco[["OUT"]] <- list(singers, golden.number)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ecogen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ecogen2geneland")
> ### * ecogen2geneland
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ecogen2geneland
> ### Title: Creating input data for Geneland with an ecogen object
> ### Aliases: ecogen2geneland
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D ecogen2geneland(eco, dir = "", ncod=1)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ecogen2geneland", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ecogen2genepop")
> ### * ecogen2genepop
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ecogen2genepop
> ### Title: Exporting an ecogen genetic data frame into Genepop format
> ### Aliases: ecogen2genepop
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D ecogen2genepop(eco, dir = "", outName = "infile.genepop.txt", grp = "pop")
> ##D # an output file "infile.genepop.txt" is generated in the working directory
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ecogen2genepop", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ecogen2genind")
> ### * ecogen2genind
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ecogen2genind
> ### Title: Conversion form ecogen to genind and genind to ecogen
> ### Aliases: ecogen2genind genind2ecogen
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D 
> ##D # ecogen to genind
> ##D outGenind <- ecogen2genind(eco)
> ##D outGenind
> ##D 
> ##D # genind to ecogen
> ##D outEco <- genind2ecogen(outGenind)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ecogen2genind", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ecogen2gstudio")
> ### * ecogen2gstudio
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ecogen2gstudio
> ### Title: Conversion from ecogen to gstudio and gstudio to ecogen
> ### Aliases: ecogen2gstudio gstudio2ecogen
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D togstudio <- ecogen2gstudio(eco, type = "codominant")
> ##D togstudio
> ##D toeco <- gstudio2ecogen(togstudio, ID = "ID", lat = "Latitude", 
> ##D lon = "Longitude", ID = "ID", struct = "pop")
> ##D toeco
> ##D # as ID, Latitude and Longitude are column names in the <togstudio> data frame 
> ##D # (that match default parameter values for gstudio2ecogen), 
> ##D # the latter is identical to this:
> ##D toeco <- gstudio2ecogen(togstudio, struct = "pop")
> ##D toeco
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ecogen2gstudio", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ecogen2hierfstat")
> ### * ecogen2hierfstat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ecogen2hierfstat
> ### Title: Converting an ecogen genetic data frame into a hierfstat data
> ###   frame
> ### Aliases: ecogen2hierfstat
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D hiereco <- ecogen2hierfstat(eco, "pop")
> ##D require("hierfstat")
> ##D basic.stats(hiereco)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ecogen2hierfstat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ecogen2spagedi")
> ### * ecogen2spagedi
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ecogen2spagedi
> ### Title: Exporting an ecogen genetic data frame into SPAGeDi format
> ### Aliases: ecogen2spagedi
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D ecogen2spagedi(eco, dir = "", pop = "pop", ndig = 1,int=2, smax=6, outName="infile.spagedi.txt")
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ecogen2spagedi", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("forestplot-methods")
> ### * forestplot-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.forestplot
> ### Title: Forestplot graphs
> ### Aliases: eco.forestplot eco.forestplot,generic-method
> ###   eco.forestplot,eco.lsa-method eco.forestplot,dataframeORmatrix-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D require(ggplot2)
> ##D # simulated confidence intervals for the null hypotesis of a variable "a"
> ##D set.seed(8)
> ##D a<-runif(10, -2, 2)
> ##D infer <- runif(10, -1, 1)
> ##D super <- runif(10, -1, 1)
> ##D infer2 <- pmin(infer, super)
> ##D super2 <- pmax(infer, super)
> ##D data <- data.frame(a, infer2, super2)
> ##D forest <- eco.forestplot(data)
> ##D forest
> ##D 
> ##D # the forestplot method support the use of ggplot2 syntax with ggplot2 graphs
> ##D forest <- eco.forestplot(data, interactivePlot = FALSE)
> ##D forest <- forest + theme_bw() + theme(legend.position="none")
> ##D forest
> ## End(Not run)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("forestplot-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("genepop2ecogen")
> ### * genepop2ecogen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: genepop2ecogen
> ### Title: Importing a Genepop file
> ### Aliases: genepop2ecogen
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # ingpop, file with Genepop format in the folder "/extdata" of the package
> ##D 
> ##D ecopath <- paste(path.package("EcoGenetics"), "/extdata/ingpop", sep = "")
> ##D ingpop <- genepop2ecogen(ecopath)
> ##D ingpop
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("genepop2ecogen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("int.order")
> ### * int.order
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: int.order
> ### Title: Ordering the rows of the data frames contained in an ecogen
> ###   object
> ### Aliases: int.order
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D eco1 <- eco
> ##D eco1[["P"]] <- eco[["P"]][sample(1:225), ]  #object with shuffled rows
> ##D eco1[["E"]] <- eco[["E"]][sample(1:225), ]
> ##D ordered <- int.order(eco1)
> ##D head(ordered[["P"]]); head(eco[["P"]])
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("int.order", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rankplot-methods")
> ### * rankplot-methods
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: eco.rankplot
> ### Title: Rankplot graphs
> ### Aliases: eco.rankplot eco.rankplot,eco.lsa,missing,missing-method
> ###   eco.rankplot,eco.lsa-method
> ###   eco.rankplot,numeric,dataframeORmatrix,missing-method
> ###   eco.rankplot,numeric-method
> ###   eco.rankplot,factor,dataframeORmatrix,missing-method
> ###   eco.rankplot,factor-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(eco3)
> ##D 
> ##D # The data set eco3 has 50 points in two sites, 
> ##D # but points are not visible in a usual X-Y plot, 
> ##D # due to the small distance among them in relation to the large
> ##D # distance between sites
> ##D 
> ##D var <- eco3[["P"]][,1]
> ##D plot(eco3[["XY"]], col = var)
> ##D x <- sample(1:100, 30)
> ##D y <- sample(1:100, 30)
> ##D 
> ##D # in a rankplot graph, the inter-individual distances are
> ##D # reduced to a single scale
> ##D rankeco3 <- eco.rankplot(var, eco3[["XY"]])
> ##D rankeco3
> ##D 
> ##D # the rankplot method supports the use of ggplot2 syntax with ggplot2 graphs
> ##D require(ggplot2)
> ##D rankeco3 <- eco.rankplot(var, eco3[["XY"]], interactivePlot = FALSE)
> ##D rankeco3 <- rankeco3 + theme_bw() + theme(legend.position="none")
> ##D rankeco3
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rankplot-methods", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("spagedi2ecogen")
> ### * spagedi2ecogen
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: spagedi2ecogen
> ### Title: Importing a SPAGeDi file, via conversion to ecogen
> ### Aliases: spagedi2ecogen
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D data(eco.test)
> ##D ecogen2spagedi(eco, dir = "", pop = "pop", ndig = 1,int=2, smax=6, outName="infile.spagedi.txt")
> ##D spagedi2ecogen("infile.spagedi.txt", sep = "")
> ## End(Not run)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("spagedi2ecogen", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.951 0.087 3.038 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
